

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Mapping reads to OTUs &mdash; Bioinformatic Methods for Biodiversity Metabarcoding  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/js/custom.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Analysing read tables" href="analysing_read_tables.html" />
    <link rel="prev" title="Mapping reads to ASVs" href="mapping_reads_asvs.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Bioinformatic Methods for Biodiversity Metabarcoding
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Example data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readprocessing.html">A: Read processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filtering.html">B: Filtering amplicons</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../asv_otu_readmap.html">C: ASVs, OTUs and read mapping</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../otudelim.html">OTU delimitation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../mapping_reads.html">Mapping reads</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="mapping_reads_asvs.html">Mapping reads to ASVs</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Mapping reads to OTUs</a></li>
<li class="toctree-l3"><a class="reference internal" href="analysing_read_tables.html">Analysing read tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../building_otu_phylogeny.html">D: Building OTU phylogeny</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../otuid.html">E: Identifying OTU sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contactus.html">Contact us</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Bioinformatic Methods for Biodiversity Metabarcoding</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../asv_otu_readmap.html">C: ASVs, OTUs and read mapping</a> &raquo;</li>
        
          <li><a href="../mapping_reads.html">Mapping reads</a> &raquo;</li>
        
      <li>Mapping reads to OTUs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/asv_otu_readmap/mapping_reads/mapping_reads_otus.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mapping-reads-to-otus">
<span id="mapping-reads-otus"></span><h1>Mapping reads to OTUs<a class="headerlink" href="#mapping-reads-to-otus" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>At first glance, we might assume that it is as straightforward to match reads to OTUs as it is to match reads  to ASVs. However, with ASVs, the sequence of an ASV represents 100% of the variation of that ASV, so we can perform strict exact matching with confidence and even less strict matching with some confidence. On the other hand, the representative sequence of an OTU does not represent all possible variation within an OTU. So exact matching of reads to OTU sequences will leave a large proportion of reads unmatched, many of which will be the reads corresponding to valid ASVs that formed part of an OTU, but did not become that OTU’s representative sequence.</p>
<p>On the other hand, matching with some threshold of similarity may often be inappropriate for OTUs, because not only might the threshold not be the same as used for OTU grouping, the computation of similarity performed by the matching may not be equivalent to the algorithm used to group OTUs. In the previous section, we used an unambiguous similarity threshold within <code class="docutils literal notranslate"><span class="pre">--usearch_global</span></code> to assign reads to ASVs, and using the same threshold to assign reads to OTUs would only be appropriate <em>if the same method was used to group ASVs into OTUs</em>.</p>
<p>If this is not the case, we must use a two-step process. First, we match reads to ASVs as we did in the previous section. Next, we use the data we generated during OTU delimitation reporting which ASVs form each OTU to reduce the ASV read map into an OTU read map, grouping together data for all of the ASVs in each OTU.</p>
<div class="green admonition">
<p class="admonition-title">Data and software</p>
<p>The input data for this tutorial is a FASTA file comprising OTU sequences, a text file listing the ASVs grouped into each OTU, and a tab-delimited table recording reads per ASV per sample. If you’re following along step-by-step, the first two files will have been produced by the <a class="reference internal" href="../otudelim.html#otu-delim"><span class="std std-ref">OTU delimitation</span></a> method of your choice. The third file will have been produced in the previous tutorial, <a class="reference internal" href="mapping_reads_asvs.html#mapping-reads-asvs"><span class="std std-ref">Mapping reads to ASVs</span></a>. Alternatively, the files <code class="docutils literal notranslate"><span class="pre">otus_greedy_0.97.fasta</span></code>, <code class="docutils literal notranslate"><span class="pre">asvgroups_greedy_0.97.uc</span></code> and <code class="docutils literal notranslate"><span class="pre">9_mbc_final_readsmap.tsv</span></code> within the <a class="reference internal" href="../../data.html#sectioncdata"><span class="std std-ref">sectionC archive</span></a> can be used as example data.</p>
<p>This tutorial uses the <a class="reference internal" href="../../gettingstarted/setup/installing_software.html#vsearch"><span class="std std-ref">VSEARCH</span></a> software.</p>
</div>
</div>
<div class="section" id="preparing-the-otu-asv-lists">
<h2>Preparing the OTU ASV lists<a class="headerlink" href="#preparing-the-otu-asv-lists" title="Permalink to this headline">¶</a></h2>
<p>For this step, you will need a file that lists the set of ASVs in each OTU, as produced as part of the OTU delimitation for each of our steps. However, because the format of this was slightly different for each OTU delimitation step, we will need to process each of them first, according to the method used. Note that there’s no particular need to run all three of these sections, just run whichever section matches the OTU delimitation method that you chose.</p>
<div class="section" id="greedy-clustering-using-vsearch">
<h3>Greedy clustering using VSEARCH<a class="headerlink" href="#greedy-clustering-using-vsearch" title="Permalink to this headline">¶</a></h3>
<p>Here our list takes the form of a table, so it’s already almost in the format we want, we just need to drop the hit statistics and strip the <code class="docutils literal notranslate"><span class="pre">;size=</span></code> tags</p>
<pre class="codebg literal-block">cut -f1,8 <span class="var">input.uc</span> | sed -e &quot;s/;size.*$//&quot; &gt; <span class="var">output.tsv</span></pre>
</div>
<div class="section" id="linkage-delimitation-using-swarm">
<h3>Linkage delimitation using swarm<a class="headerlink" href="#linkage-delimitation-using-swarm" title="Permalink to this headline">¶</a></h3>
<p>Here each line of the file is a list of ASVs in one OTU, with the centroid sequence being the first ASV name. The following command strips out the <code class="docutils literal notranslate"><span class="pre">size=</span></code> tags then converts into a table by looping through each line one by one, storing the first item in each line, then looping through the items in a line to generate the output.</p>
<pre class="codebg literal-block">sed -e &quot;s/;size=[^ ]*//g&quot; <span class="var">input.tsv</span> |
while read l;
do
        n=${l%% *};
        for a in $l;
        do
                echo -e &quot;$n\t$a&quot;;
        done;
done &gt; <span class="var">output.tsv</span></pre>
</div>
<div class="section" id="bayesian-delimitation-using-crop">
<h3>Bayesian delimitation using CROP<a class="headerlink" href="#bayesian-delimitation-using-crop" title="Permalink to this headline">¶</a></h3>
<p>The file output by <strong>CROP</strong> is similar to that output by swarm. The first item on each line is the name of the centroid sequence, which is followed by a tab then a list of all the ASV reads forming that OTU. Remember, <strong>CROP</strong> worked on ASV reads, i.e. one sequence for each ASV for each read it had in the original dataset. So we will see duplicated ASV names within OTUs. We don’t need to strip out <code class="docutils literal notranslate"><span class="pre">;size=</span></code> tags though!</p>
<p>The following command is similar to the command for <strong>swarm</strong>. We convert commas to spaces, then loop through the table in the same way, this time instead of using a single variable <code class="docutils literal notranslate"><span class="pre">$l</span></code> for a line we use two, because we’ve specified that the Input File should be Separated by tab (<code class="docutils literal notranslate"><span class="pre">IFS=$'\t'</span></code>). We generate a line for each ASV read as we did before, but this time we pipe this into a <code class="docutils literal notranslate"><span class="pre">sort</span></code> then find the <code class="docutils literal notranslate"><span class="pre">uniq</span></code> lines to strip out those duplicates.</p>
<pre class="codebg literal-block">sed -e &quot;s/,/ /g&quot; <span class="var">input.list</span> |
while IFS=$'\t' read -r n l;
do
        for a in $l;
        do
                 echo -e &quot;$n\t$a&quot;;
        done | sort | uniq;
done &gt; <span class="var">output.tsv</span></pre>
</div>
<div class="section" id="extension-phylogenetic-delimitation-using-bptp">
<h3>Extension: phylogenetic delimitation using bPTP<a class="headerlink" href="#extension-phylogenetic-delimitation-using-bptp" title="Permalink to this headline">¶</a></h3>
<p>If you also tried out using <strong>bPTP</strong> for OTU delimitation, when we re-processed the output for <strong>bPTP</strong> we actually made it into the same format as for <strong>swarm</strong>. So you can use exactly the same code as for the <strong>swarm</strong> ASV grouping file, above.</p>
</div>
</div>
<div class="section" id="joining-our-data">
<h2>Joining our data<a class="headerlink" href="#joining-our-data" title="Permalink to this headline">¶</a></h2>
<p>Now we can join the output from the above to your table of read counts per ASV per sample, as produced in the previous step, with ASVs as the rows and samples as the columns. We do this using the linux <code class="docutils literal notranslate"><span class="pre">join</span></code> command. The first table will be our table of ASVs and OTUs: the ASVs are column two, so we specify that the join column for the first table is column two (<code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">2</span></code>). The second table is our ASV read counts table, where the join column (the column of ASV names) is column one (<code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">1</span></code>).</p>
<pre class="codebg literal-block">join -1 2 -2 1 &lt;(sort -k2 <span class="var">ASV-OTU.tsv</span>) <span class="var">ASV_read_map.tsv</span> &gt; output.tsv</pre>
<p>Note that we sorted the ASV-to-OTU table, this is a necessary step for <code class="docutils literal notranslate"><span class="pre">join</span></code> to work properly.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">head</span></code> to view the output file. You’ll see two columns of sequence names followed by the read count data. The first column is the join column, i.e. the ASV names. The second column is the other column from the ASV-to-OTU table, i.e. the OTU centroid names. We can now get rid of the first column, the ASV names, after changing the file from space-delimited back to tab-delimited</p>
<pre class="codebg literal-block">sed -e &quot;s/ /\t/g&quot; <span class="var">input.tsv</span> | cut -f2- &gt; <span class="var">output.tsv</span></pre>
<p>You might have noticed that we’ve lost the header column from the ASV read map table: this is because it didn’t have an ASV name in column 1 to match against the other table. No matter, we can bring it back again.</p>
<pre class="codebg literal-block">cat &lt;(head -1 <span class="var">ASV_read_map.tsv</span>) <span class="var">input.tsv</span> &gt; <span class="var">output.tsv</span></pre>
</div>
<div class="section" id="summing-over-otus">
<h2>Summing over OTUs<a class="headerlink" href="#summing-over-otus" title="Permalink to this headline">¶</a></h2>
<p>The last issue is that we have multiple rows for each OTU, and we want to sum all occurences of all ASVs within each OTU into one row. We can do this using an R one-liner.</p>
<pre class="codebg literal-block">Rscript -e 'x&lt;-read.table(&quot;<span class="var">input.tsv</span>&quot;,header=T,comment.char=&quot;&quot;,sep=&quot;\t&quot;);rowsum(x[,-1],x[,1])' &gt; <span class="var">output.tsv</span></pre>
<p>This output gives the total read numbers for all ASVs within each OTU by sample.</p>
</div>
<div class="section" id="shortcut-for-greedy-clustering">
<h2>Shortcut for greedy clustering<a class="headerlink" href="#shortcut-for-greedy-clustering" title="Permalink to this headline">¶</a></h2>
<p>In the introduction, we discussed that simply matching reads directly to OTUs is not appropriate unless the method we use to match reads to OTUs accurately reflects the method by which OTUs were initially delimited. In fact, for greedy clustering, this is true. Greedy clustering uses pairwise similarity to group ASVs, working in order of ASV frequency which has the effect that ties are broken by choosing the more frequent cluster. Given that the outputs are thus ordered by frequency, and that <code class="docutils literal notranslate"><span class="pre">--usearch_global</span></code> chooses the the first record in the database in the case of ties, we can in fact search reads directly against the OTUs <strong>for greedy clustering only</strong>. This uses the same command as we saw in less-strict ASV mapping:</p>
<pre class="codebg literal-block">vsearch --usearch_global <span class="var">reads.fasta</span> -db <span class="var">​otus.fasta</span> -id 0.97 -otutabout <span class="var">output.tsv</span></pre>
<p>We use the <code class="docutils literal notranslate"><span class="pre">-id</span> <span class="pre">0.97</span></code> parameter to set a 3% similarity cutoff for OTUs that have been clustered at 97% similarity. Obviously if you had used a different similarity threshold when clustering, you’d use the same value here.</p>
<p>This shortcut is <strong>only</strong> available for greedy clustering. To the best of our knowledge, the above two-step process is the most appropriate way to map reads to OTUs for other types of OTU delimitation. Hopefully we’ve persuaded you that to map reads using this shortcut for <strong>swarm</strong>, <strong>CROP</strong> or another method would likely give erroneous read counts. Of course, it’s likely that the majority of read assignments would probably be correct, since in most cases the most similar OTU to a read is likely the appropriate read, but its the handling of outlying variants that could cause errors and ambiguities to creep in.</p>
</div>
<div class="section" id="next-steps">
<h2>Next steps<a class="headerlink" href="#next-steps" title="Permalink to this headline">¶</a></h2>
<p>The output from this subsection forms the metabarcoding equivalent of a site by species table ready to be used in downstream analysis, although we would recommend some further filtering which we discuss in the <a class="reference internal" href="analysing_read_tables.html#analysis"><span class="std std-ref">Analysing read tables</span></a> subsection.</p>
<p>You may want to learn about building a phylogeny of your OTUs in the <a class="reference internal" href="../../building_otu_phylogeny.html#phylogeny"><span class="std std-ref">Building OTU phylogeny</span></a> section, or taxonomically identifying and/or classifying your OTUs in the <a class="reference internal" href="../../otuid.html#otuid"><span class="std std-ref">Identifying OTU sequences</span></a> section.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="analysing_read_tables.html" class="btn btn-neutral float-right" title="Analysing read tables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="mapping_reads_asvs.html" class="btn btn-neutral float-left" title="Mapping reads to ASVs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, The Vogler Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
    <p><br>Creedy, Vogler & Penlington, Natural History Museum London, Bioinformatic Methods for Biodiversity Metabarcoding. This site is a a deliverable of the iBioGen consortium funded by EU grant agreement No 810729, the content of this site is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="blank">Creative Commons Attribution ShareAlike 4.0 License</a></p>


</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>